From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Keeley Hammond <khammond@slack-corp.com>
Date: Wed, 21 Aug 2024 19:00:00 -0700
Subject: feat: make MacOS SCContentSharingPicker work in Electron

This patch is a work in progress that contains assorted changes to make the MacOS SCContentSharingPicker upstream implementation work within Electron. If this comment is still in this patch during PR review, it is not ready for prime time

This patch can be removed after our desktopCapturer is refactored.

diff --git a/chrome/browser/media/webrtc/desktop_media_list_base.cc b/chrome/browser/media/webrtc/desktop_media_list_base.cc
index 6599311831b638f49658e768fe35e19e9961ef1d..9979651fc2bafa1f363a34b2cd60d4d7219711f0 100644
--- a/chrome/browser/media/webrtc/desktop_media_list_base.cc
+++ b/chrome/browser/media/webrtc/desktop_media_list_base.cc
@@ -15,6 +15,7 @@
 #include "base/functional/bind.h"
 #include "base/hash/hash.h"
 #include "chrome/browser/media/webrtc/desktop_media_list.h"
+#include "chrome/browser/media/webrtc/thumbnail_capturer_mac.h"
 #include "content/public/browser/browser_task_traits.h"
 #include "content/public/browser/browser_thread.h"
 #include "third_party/skia/include/core/SkBitmap.h"
@@ -77,7 +78,13 @@ void DesktopMediaListBase::StartUpdating(DesktopMediaListObserver* observer) {
 void DesktopMediaListBase::Update(UpdateCallback callback, bool refresh_thumbnails) {
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
   DCHECK(sources_.empty());
+#if BUILDFLAG(IS_MAC)
+  if (!ShouldUseSCContentSharingPicker()) {
+    DCHECK(!refresh_callback_);
+  };
+#else
   DCHECK(!refresh_callback_);
+#endif
   refresh_callback_ = std::move(callback);
   Refresh(refresh_thumbnails);
 }
diff --git a/chrome/browser/media/webrtc/native_desktop_media_list.cc b/chrome/browser/media/webrtc/native_desktop_media_list.cc
index 95a1c18438619c19a1dd71ca3e6e23af5e0ebacb..68ece50018124992f951557e817a12aa45d65956 100644
--- a/chrome/browser/media/webrtc/native_desktop_media_list.cc
+++ b/chrome/browser/media/webrtc/native_desktop_media_list.cc
@@ -46,6 +46,7 @@
 #endif
 
 #if BUILDFLAG(IS_MAC)
+#include "chrome/browser/media/webrtc/thumbnail_capturer_mac.h"
 #include "components/remote_cocoa/browser/scoped_cg_window_id.h"
 #endif
 
@@ -545,11 +546,23 @@ NativeDesktopMediaList::Worker::FormatSources(
         break;
 
       case DesktopMediaID::Type::TYPE_WINDOW:
+#if BUILDFLAG(IS_MAC)
+        // If using NativeScreenCapturePickerMac,
+        // skipping the picker will skip the first window selection.
+        if (ShouldUseSCContentSharingPicker()) {
+          title = base::UTF8ToUTF16(sources[i].title);
+        } else if (sources[i].id == excluded_window_id) {
+        // Skip the picker dialog window.
+          continue;
+        }
+        title = base::UTF8ToUTF16(sources[i].title);
+ #else
         // Skip the picker dialog window.
         if (sources[i].id == excluded_window_id) {
           continue;
         }
         title = base::UTF8ToUTF16(sources[i].title);
+#endif
         break;
 
       default:
diff --git a/chrome/browser/media/webrtc/thumbnail_capturer_mac.h b/chrome/browser/media/webrtc/thumbnail_capturer_mac.h
index 12a74f8f32cc00a7f3d7802865ae4b309961341d..acbcfb08ae8c44e24a04b326096289428bc6ff60 100644
--- a/chrome/browser/media/webrtc/thumbnail_capturer_mac.h
+++ b/chrome/browser/media/webrtc/thumbnail_capturer_mac.h
@@ -8,6 +8,9 @@
 #include "chrome/browser/media/webrtc/desktop_media_list.h"
 #include "chrome/browser/media/webrtc/thumbnail_capturer.h"
 
+// Returns true if the SCK sharing picker is available and enabled.
+bool ShouldUseSCContentSharingPicker();
+
 // Returns true if the SCK thumbnail capturer is available and enabled.
 bool ShouldUseThumbnailCapturerMac(DesktopMediaList::Type type);
 
diff --git a/chrome/browser/media/webrtc/thumbnail_capturer_mac.mm b/chrome/browser/media/webrtc/thumbnail_capturer_mac.mm
index 2215bf4589342fa4619fb58ec3e21ff5ef3ed3b4..f674a907a96a7a76a514d798779aa726441cebc9 100644
--- a/chrome/browser/media/webrtc/thumbnail_capturer_mac.mm
+++ b/chrome/browser/media/webrtc/thumbnail_capturer_mac.mm
@@ -1006,6 +1006,8 @@ void OnCapturedFrame(base::apple::ScopedCFTypeRef<CGImageRef> image,
                                       source_id);
 }
 
+}  // namespace
+
 bool ShouldUseSCContentSharingPicker() {
   if (@available(macOS 15.0, *)) {
     if (base::FeatureList::IsEnabled(kUseSCContentSharingPicker)) {
@@ -1020,8 +1022,6 @@ bool ShouldUseSCContentSharingPicker() {
   return false;
 }
 
-}  // namespace
-
 bool ShouldUseThumbnailCapturerMac(DesktopMediaList::Type type) {
   // There was a bug in ScreenCaptureKit that was fixed in 14.4,
   // see b/40076027.
diff --git a/content/browser/media/capture/native_screen_capture_picker_mac.mm b/content/browser/media/capture/native_screen_capture_picker_mac.mm
index b34d8402c213329620683e41588c0411d45124fb..1b8e95f476a032f60ea7e578fac480344924ab50 100644
--- a/content/browser/media/capture/native_screen_capture_picker_mac.mm
+++ b/content/browser/media/capture/native_screen_capture_picker_mac.mm
@@ -132,8 +132,11 @@ void Open(DesktopMediaID::Type type,
     base::OnceCallback<void()> cancel_callback,
     base::OnceCallback<void()> error_callback) {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  // Chrome doesn't allow both screens & windows in their picker,
+  // but Electron does - add a check for TYPE_NONE.
   CHECK(type == DesktopMediaID::Type::TYPE_SCREEN ||
-        type == DesktopMediaID::Type::TYPE_WINDOW);
+        type == DesktopMediaID::Type::TYPE_WINDOW ||
+        type == DesktopMediaID::Type::TYPE_NONE);
   if (@available(macOS 14.0, *)) {
     NSNumber* source_id = @(next_id_);
     auto picker_observer = [[PickerObserver alloc]
@@ -150,19 +153,13 @@ void Open(DesktopMediaID::Type type,
     // TODO(https://crbug.com/360781940): Add support for changing selected
     // content. The problem to solve is how this should interact with stream
     // restart.
-    config.allowsChangingSelectedContent = false;
+    config.allowsChangingSelectedContent = true;
     NSNumber* max_stream_count = @(kMaxContentShareCountValue.Get());
-    if (type == DesktopMediaID::Type::TYPE_SCREEN) {
-      config.allowedPickerModes = SCContentSharingPickerModeSingleDisplay;
-      picker.defaultConfiguration = config;
-      picker.maximumStreamCount = max_stream_count;
-      [picker presentPickerUsingContentStyle:SCShareableContentStyleDisplay];
-    } else {
-      config.allowedPickerModes = SCContentSharingPickerModeSingleWindow;
-      picker.defaultConfiguration = config;
-      picker.maximumStreamCount = max_stream_count;
-      [picker presentPickerUsingContentStyle:SCShareableContentStyleWindow];
-    }
+    // Chrome doesn't allow both screens & windows in their picker,
+    // but Electron does; we patch out the MediaID::Type conditional here
+    picker.defaultConfiguration = config;
+    picker.maximumStreamCount = max_stream_count;
+    [picker present];
   } else {
     NOTREACHED();
   }
