From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Keeley Hammond <khammond@slack-corp.com>
Date: Thu, 9 Jan 2025 09:33:36 -0800
Subject: fix: revert mac webcontents occulusion feature flag removal

Chrome has removed this WebContentsOcclusion feature flag upstream,
which is now causing our visibility tests to break. This patch
restores the occlusion flag to ensure the roll can continue
while we debug the issue.

This patch can be removed when the root cause because the visibility
specs failing on MacOS only is debugged and fixed. It should be removed
before Electron 35's stable date.

Revert "Code Health: Clean up stale MacWebContentsOcclusion"

This reverts commit ef865130abd5539e7bce12308659b19980368f12.

diff --git a/content/app_shim_remote_cocoa/web_contents_occlusion_checker_mac.h b/content/app_shim_remote_cocoa/web_contents_occlusion_checker_mac.h
index 428902f90950b2e9434c8a624a313268ebb80cd4..afcc3bc481be6a16119f7e2af647276cb0dafa1e 100644
--- a/content/app_shim_remote_cocoa/web_contents_occlusion_checker_mac.h
+++ b/content/app_shim_remote_cocoa/web_contents_occlusion_checker_mac.h
@@ -12,6 +12,8 @@
 #import "content/app_shim_remote_cocoa/web_contents_view_cocoa.h"
 #include "content/common/web_contents_ns_view_bridge.mojom.h"
 
+extern CONTENT_EXPORT const base::FeatureParam<bool>
+    kEnhancedWindowOcclusionDetection;
 extern CONTENT_EXPORT const base::FeatureParam<bool>
     kDisplaySleepAndAppHideDetection;
 
diff --git a/content/app_shim_remote_cocoa/web_contents_occlusion_checker_mac.mm b/content/app_shim_remote_cocoa/web_contents_occlusion_checker_mac.mm
index a1b1d79e53eb429e3f8991e45b651af9a8b2a3ba..1c5987147463bf6f369b6736b5c34d377fa5b3ba 100644
--- a/content/app_shim_remote_cocoa/web_contents_occlusion_checker_mac.mm
+++ b/content/app_shim_remote_cocoa/web_contents_occlusion_checker_mac.mm
@@ -19,6 +19,12 @@
 #include "content/public/browser/content_browser_client.h"
 #include "content/public/common/content_client.h"
 
+using features::kMacWebContentsOcclusion;
+
+// Experiment features.
+const base::FeatureParam<bool> kEnhancedWindowOcclusionDetection{
+    &kMacWebContentsOcclusion, "EnhancedWindowOcclusionDetection", false};
+
 namespace {
 
 NSString* const kWindowDidChangePositionInWindowList =
@@ -92,6 +98,7 @@ + (void)resetSharedInstanceForTesting {
 - (instancetype)init {
   self = [super init];
 
+  DCHECK(base::FeatureList::IsEnabled(kMacWebContentsOcclusion));
   DCHECK(IsBrowserProcess());
   if (!IsBrowserProcess()) {
     static auto* const crash_key = base::debug::AllocateCrashKeyString(
@@ -127,7 +134,8 @@ - (void)dealloc {
 
 - (BOOL)isManualOcclusionDetectionEnabled {
   return [WebContentsOcclusionCheckerMac
-      manualOcclusionDetectionSupportedForCurrentMacOSVersion];
+             manualOcclusionDetectionSupportedForCurrentMacOSVersion] &&
+         kEnhancedWindowOcclusionDetection.Get();
 }
 
 // Alternative implementation of orderWindow:relativeTo:. Replaces
diff --git a/content/app_shim_remote_cocoa/web_contents_view_cocoa.mm b/content/app_shim_remote_cocoa/web_contents_view_cocoa.mm
index fc4de264da58bcea7329c82409d1087e67b62f25..d0c206a2bd355cb7db688febed3b5daa4d9f3a32 100644
--- a/content/app_shim_remote_cocoa/web_contents_view_cocoa.mm
+++ b/content/app_shim_remote_cocoa/web_contents_view_cocoa.mm
@@ -29,6 +29,7 @@
 #include "ui/resources/grit/ui_resources.h"
 
 using content::DropData;
+using features::kMacWebContentsOcclusion;
 using remote_cocoa::mojom::DraggingInfo;
 using remote_cocoa::mojom::SelectionDirection;
 
@@ -126,12 +127,17 @@ @implementation WebContentsViewCocoa {
 
   gfx::Rect _windowControlsOverlayRect;
 
+  // TODO(crbug.com/40593221): Remove this when kMacWebContentsOcclusion
+  // is enabled by default.
+  BOOL _inFullScreenTransition;
   BOOL _willSetWebContentsOccludedAfterDelay;
 }
 
 + (void)initialize {
-  // Create the WebContentsOcclusionCheckerMac shared instance.
-  [WebContentsOcclusionCheckerMac sharedInstance];
+  if (base::FeatureList::IsEnabled(kMacWebContentsOcclusion)) {
+    // Create the WebContentsOcclusionCheckerMac shared instance.
+    [WebContentsOcclusionCheckerMac sharedInstance];
+  }
 }
 
 - (instancetype)initWithViewsHostableView:(ui::ViewsHostableView*)v {
@@ -434,6 +440,7 @@ - (void)updateWebContentsVisibility:
     (remote_cocoa::mojom::Visibility)visibility {
   using remote_cocoa::mojom::Visibility;
 
+  DCHECK(base::FeatureList::IsEnabled(kMacWebContentsOcclusion));
   if (!_host)
     return;
 
@@ -479,6 +486,21 @@ - (void)updateWebContentsVisibility {
   [self updateWebContentsVisibility:visibility];
 }
 
+- (void)legacyUpdateWebContentsVisibility {
+  using remote_cocoa::mojom::Visibility;
+  DCHECK(!base::FeatureList::IsEnabled(kMacWebContentsOcclusion));
+  if (!_host || _inFullScreenTransition)
+    return;
+  Visibility visibility = Visibility::kVisible;
+  if ([self isHiddenOrHasHiddenAncestor] || ![self window])
+    visibility = Visibility::kHidden;
+  else if ([[self window] occlusionState] & NSWindowOcclusionStateVisible)
+    visibility = Visibility::kVisible;
+  else
+    visibility = Visibility::kOccluded;
+  _host->OnWindowVisibilityChanged(visibility);
+}
+
 - (void)resizeSubviewsWithOldSize:(NSSize)oldBoundsSize {
   // Subviews do not participate in auto layout unless the the size this view
   // changes. This allows RenderWidgetHostViewMac::SetBounds(..) to select a
@@ -501,22 +523,72 @@ - (void)viewWillMoveToWindow:(NSWindow*)newWindow {
 
   NSWindow* oldWindow = [self window];
 
-  if (oldWindow) {
-    [notificationCenter
-        removeObserver:self
-                  name:NSWindowDidChangeOcclusionStateNotification
-                object:oldWindow];
+  if (base::FeatureList::IsEnabled(kMacWebContentsOcclusion)) {
+    if (oldWindow) {
+      [notificationCenter
+          removeObserver:self
+                    name:NSWindowDidChangeOcclusionStateNotification
+                  object:oldWindow];
+    }
+
+    if (newWindow) {
+      [notificationCenter
+          addObserver:self
+             selector:@selector(windowChangedOcclusionState:)
+                 name:NSWindowDidChangeOcclusionStateNotification
+               object:newWindow];
+    }
+
+    return;
   }
 
+  _inFullScreenTransition = NO;
+  if (oldWindow) {
+    NSArray* notificationsToRemove = @[
+      NSWindowDidChangeOcclusionStateNotification,
+      NSWindowWillEnterFullScreenNotification,
+      NSWindowDidEnterFullScreenNotification,
+      NSWindowWillExitFullScreenNotification,
+      NSWindowDidExitFullScreenNotification
+    ];
+    for (NSString* notificationName in notificationsToRemove) {
+      [notificationCenter removeObserver:self
+                                    name:notificationName
+                                  object:oldWindow];
+    }
+  }
   if (newWindow) {
     [notificationCenter addObserver:self
                            selector:@selector(windowChangedOcclusionState:)
                                name:NSWindowDidChangeOcclusionStateNotification
                              object:newWindow];
+    // The fullscreen transition causes spurious occlusion notifications.
+    // See https://crbug.com/1081229
+    [notificationCenter addObserver:self
+                           selector:@selector(fullscreenTransitionStarted:)
+                               name:NSWindowWillEnterFullScreenNotification
+                             object:newWindow];
+    [notificationCenter addObserver:self
+                           selector:@selector(fullscreenTransitionComplete:)
+                               name:NSWindowDidEnterFullScreenNotification
+                             object:newWindow];
+    [notificationCenter addObserver:self
+                           selector:@selector(fullscreenTransitionStarted:)
+                               name:NSWindowWillExitFullScreenNotification
+                             object:newWindow];
+    [notificationCenter addObserver:self
+                           selector:@selector(fullscreenTransitionComplete:)
+                               name:NSWindowDidExitFullScreenNotification
+                             object:newWindow];
   }
 }
 
 - (void)windowChangedOcclusionState:(NSNotification*)aNotification {
+  if (!base::FeatureList::IsEnabled(kMacWebContentsOcclusion)) {
+    [self legacyUpdateWebContentsVisibility];
+    return;
+  }
+
   // Only respond to occlusion notifications sent by the occlusion checker.
   NSDictionary* userInfo = [aNotification userInfo];
   NSString* occlusionCheckerKey = [WebContentsOcclusionCheckerMac className];
@@ -524,15 +596,40 @@ - (void)windowChangedOcclusionState:(NSNotification*)aNotification {
     [self updateWebContentsVisibility];
 }
 
+- (void)fullscreenTransitionStarted:(NSNotification*)notification {
+  DCHECK(!base::FeatureList::IsEnabled(kMacWebContentsOcclusion));
+  _inFullScreenTransition = YES;
+}
+
+- (void)fullscreenTransitionComplete:(NSNotification*)notification {
+  DCHECK(!base::FeatureList::IsEnabled(kMacWebContentsOcclusion));
+  _inFullScreenTransition = NO;
+}
+
 - (void)viewDidMoveToWindow {
+  if (!base::FeatureList::IsEnabled(kMacWebContentsOcclusion)) {
+    [self legacyUpdateWebContentsVisibility];
+    return;
+  }
+
   [self updateWebContentsVisibility];
 }
 
 - (void)viewDidHide {
+  if (!base::FeatureList::IsEnabled(kMacWebContentsOcclusion)) {
+    [self legacyUpdateWebContentsVisibility];
+    return;
+  }
+
   [self updateWebContentsVisibility];
 }
 
 - (void)viewDidUnhide {
+  if (!base::FeatureList::IsEnabled(kMacWebContentsOcclusion)) {
+    [self legacyUpdateWebContentsVisibility];
+    return;
+  }
+
   [self updateWebContentsVisibility];
 }
 
diff --git a/content/app_shim_remote_cocoa/window_occlusion_browsertest_mac.mm b/content/app_shim_remote_cocoa/window_occlusion_browsertest_mac.mm
index b40cfd9de8804dd92e64572b3349468123a314b1..8056e88403f7b43fcb760c441bbb55ca7458e870 100644
--- a/content/app_shim_remote_cocoa/window_occlusion_browsertest_mac.mm
+++ b/content/app_shim_remote_cocoa/window_occlusion_browsertest_mac.mm
@@ -16,15 +16,19 @@
 #include "content/public/test/browser_test.h"
 #include "content/public/test/content_browser_test.h"
 
-using content::DropData;
 using remote_cocoa::mojom::DraggingInfo;
 using remote_cocoa::mojom::DraggingInfoPtr;
 using remote_cocoa::mojom::SelectionDirection;
+using content::DropData;
 
 namespace {
 
 const int kNeverCalled = -100;
 
+struct FeatureState {
+  bool enhanced_occlusion_detection_enabled = false;
+};
+
 struct Version {
   int packed_version;
   bool supported;
@@ -329,8 +333,21 @@ void EndDrag(uint32_t drag_operation,
 };
 
 // Sets up occlusion tests.
-class WindowOcclusionBrowserTestMac : public ContentBrowserTest {
+class WindowOcclusionBrowserTestMac
+    : public ::testing::WithParamInterface<FeatureState>,
+      public ContentBrowserTest {
  public:
+  WindowOcclusionBrowserTestMac() {
+    if (GetParam().enhanced_occlusion_detection_enabled) {
+      base::FieldTrialParams params;
+      params["EnhancedWindowOcclusionDetection"] = "true";
+      features_.InitAndEnableFeatureWithParameters(
+          features::kMacWebContentsOcclusion, params);
+    } else {
+      features_.InitAndDisableFeature(features::kMacWebContentsOcclusion);
+    }
+  }
+
   void SetUp() override {
     if (![NSClassFromString(@"WebContentsOcclusionCheckerMac")
             manualOcclusionDetectionSupportedForCurrentMacOSVersion]) {
@@ -380,6 +397,9 @@ bool WebContentsAwaitingUpdates() {
   }
 
   void WaitForOcclusionUpdate() {
+    if (!base::FeatureList::IsEnabled(features::kMacWebContentsOcclusion))
+      return;
+
     while ([[NSClassFromString(@"WebContentsOcclusionCheckerMac")
                sharedInstance] occlusionStateUpdatesAreScheduledForTesting] ||
            WebContentsAwaitingUpdates()) {
@@ -460,10 +480,16 @@ void InitWindowB(NSRect window_frame = NSZeroRect) {
   void OrderWindowFront(NSWindow* window) {
     [[maybe_unused]] WebContentVisibilityUpdateCounter* watcher;
 
+    if (!kEnhancedWindowOcclusionDetection.Get()) {
+      watcher = [[WebContentVisibilityUpdateCounter alloc] init];
+    }
+
     [window orderFront:nil];
     ASSERT_TRUE([window isVisible]);
 
-    WaitForOcclusionUpdate();
+    if (kEnhancedWindowOcclusionDetection.Get()) {
+      WaitForOcclusionUpdate();
+    }
   }
 
   void OrderWindowOut(NSWindow* window) {
@@ -549,8 +575,34 @@ void TearDownInProcessBrowserTestFixture() override {
   WebContentsNSViewHostStub host_a_;
 };
 
+using WindowOcclusionBrowserTestMacWithoutOcclusionFeature =
+    WindowOcclusionBrowserTestMac;
+using WindowOcclusionBrowserTestMacWithOcclusionDetectionFeature =
+    WindowOcclusionBrowserTestMac;
+
+// Tests that should only work without the occlusion detection feature.
+INSTANTIATE_TEST_SUITE_P(NoFeature,
+                         WindowOcclusionBrowserTestMacWithoutOcclusionFeature,
+                         ::testing::Values(FeatureState{
+                             .enhanced_occlusion_detection_enabled = false}));
+
+// Tests that should work with or without the occlusion detection feature.
+INSTANTIATE_TEST_SUITE_P(
+    Common,
+    WindowOcclusionBrowserTestMac,
+    ::testing::Values(
+        FeatureState{.enhanced_occlusion_detection_enabled = false},
+        FeatureState{.enhanced_occlusion_detection_enabled = true}));
+
+// Tests that require enhanced window occlusion detection.
+INSTANTIATE_TEST_SUITE_P(
+    EnhancedWindowOcclusionDetection,
+    WindowOcclusionBrowserTestMacWithOcclusionDetectionFeature,
+    ::testing::Values(FeatureState{
+        .enhanced_occlusion_detection_enabled = true}));
+
 // Tests that we correctly disallow unsupported macOS versions.
-IN_PROC_BROWSER_TEST_F(WindowOcclusionBrowserTestMac, MacOSVersionChecking) {
+IN_PROC_BROWSER_TEST_P(WindowOcclusionBrowserTestMac, MacOSVersionChecking) {
   Class WebContentsOcclusionCheckerMac =
       NSClassFromString(@"WebContentsOcclusionCheckerMac");
   std::vector<Version> versions = {
@@ -565,8 +617,45 @@ void TearDownInProcessBrowserTestFixture() override {
   }
 }
 
+// Tests that enhanced occlusion detection isn't triggered if the feature's
+// not enabled.
+IN_PROC_BROWSER_TEST_P(WindowOcclusionBrowserTestMacWithoutOcclusionFeature,
+                       ManualOcclusionDetectionDisabled) {
+  InitWindowA();
+
+  // Create a second window and place it exactly over window_a. The window
+  // should still be considered visible.
+  InitWindowB([window_a_ frame]);
+  EXPECT_EQ(WindowAWebContentsVisibility(),
+            remote_cocoa::mojom::Visibility::kVisible);
+}
+
+// Test that display sleep and app hide detection don't work if the feature's
+// not enabled.
+IN_PROC_BROWSER_TEST_P(WindowOcclusionBrowserTestMacWithoutOcclusionFeature,
+                       OcclusionDetectionOnDisplaySleepDisabled) {
+  InitWindowA();
+
+  EXPECT_EQ(WindowAWebContentsVisibility(),
+            remote_cocoa::mojom::Visibility::kVisible);
+
+  // Fake a display sleep notification.
+  ASSERT_TRUE(NSWorkspace.sharedWorkspace.notificationCenter);
+  [[maybe_unused]] WebContentVisibilityUpdateCounter* watcher =
+      [[WebContentVisibilityUpdateCounter alloc] init];
+
+  [NSWorkspace.sharedWorkspace.notificationCenter
+      postNotificationName:NSWorkspaceScreensDidSleepNotification
+                    object:nil
+                  userInfo:nil];
+
+  EXPECT_TRUE([WebContentVisibilityUpdateCounter methodNeverCalled]);
+  EXPECT_EQ(WindowAWebContentsVisibility(),
+            remote_cocoa::mojom::Visibility::kVisible);
+}
+
 // Test that we properly handle occlusion notifications from macOS.
-IN_PROC_BROWSER_TEST_F(WindowOcclusionBrowserTestMac,
+IN_PROC_BROWSER_TEST_P(WindowOcclusionBrowserTestMac,
                        MacOSOcclusionNotifications) {
   InitWindowA();
 
@@ -583,8 +672,9 @@ void TearDownInProcessBrowserTestFixture() override {
             remote_cocoa::mojom::Visibility::kVisible);
 }
 
-IN_PROC_BROWSER_TEST_F(WindowOcclusionBrowserTestMac,
-                       ManualOcclusionDetection) {
+IN_PROC_BROWSER_TEST_P(
+    WindowOcclusionBrowserTestMacWithOcclusionDetectionFeature,
+    ManualOcclusionDetection) {
   InitWindowA();
 
   // Create a second window and place it exactly over window_a. Unlike macOS,
@@ -620,8 +710,9 @@ void TearDownInProcessBrowserTestFixture() override {
 }
 
 // Checks manual occlusion detection as windows change display order.
-IN_PROC_BROWSER_TEST_F(WindowOcclusionBrowserTestMac,
-                       ManualOcclusionDetectionOnWindowOrderChange) {
+IN_PROC_BROWSER_TEST_P(
+    WindowOcclusionBrowserTestMacWithOcclusionDetectionFeature,
+    ManualOcclusionDetectionOnWindowOrderChange) {
   InitWindowA();
 
   // Size and position the second window so that it exactly covers the
@@ -643,8 +734,9 @@ void TearDownInProcessBrowserTestFixture() override {
 
 // Checks that window_a, occluded by window_b, transitions to kVisible while the
 // user resizes window_b.
-IN_PROC_BROWSER_TEST_F(WindowOcclusionBrowserTestMac,
-                       ManualOcclusionDetectionOnWindowLiveResize) {
+IN_PROC_BROWSER_TEST_P(
+    WindowOcclusionBrowserTestMacWithOcclusionDetectionFeature,
+    ManualOcclusionDetectionOnWindowLiveResize) {
   InitWindowA();
 
   // Size and position the second window so that it exactly covers the
@@ -673,8 +765,9 @@ void TearDownInProcessBrowserTestFixture() override {
 
 // Checks that window_a, occluded by window_b, transitions to kVisible when
 // window_b is set to close.
-IN_PROC_BROWSER_TEST_F(WindowOcclusionBrowserTestMac,
-                       ManualOcclusionDetectionOnWindowClose) {
+IN_PROC_BROWSER_TEST_P(
+    WindowOcclusionBrowserTestMacWithOcclusionDetectionFeature,
+    ManualOcclusionDetectionOnWindowClose) {
   InitWindowA();
 
   // Size and position the second window so that it exactly covers the
@@ -695,8 +788,9 @@ void TearDownInProcessBrowserTestFixture() override {
 
 // Checks that window_a, occluded by window_b and window_c, remains kOccluded
 // when window_b is set to close.
-IN_PROC_BROWSER_TEST_F(WindowOcclusionBrowserTestMac,
-                       ManualOcclusionDetectionOnMiddleWindowClose) {
+IN_PROC_BROWSER_TEST_P(
+    WindowOcclusionBrowserTestMacWithOcclusionDetectionFeature,
+    ManualOcclusionDetectionOnMiddleWindowClose) {
   InitWindowA();
 
   // Size and position the second window so that it exactly covers the
@@ -727,8 +821,9 @@ void TearDownInProcessBrowserTestFixture() override {
 }
 
 // Checks that web contents are marked kHidden on display sleep.
-IN_PROC_BROWSER_TEST_F(WindowOcclusionBrowserTestMac,
-                       OcclusionDetectionOnDisplaySleep) {
+IN_PROC_BROWSER_TEST_P(
+    WindowOcclusionBrowserTestMacWithOcclusionDetectionFeature,
+    OcclusionDetectionOnDisplaySleep) {
   InitWindowA();
 
   EXPECT_EQ(WindowAWebContentsVisibility(),
@@ -749,8 +844,9 @@ void TearDownInProcessBrowserTestFixture() override {
 
 // Checks that occlusion updates are ignored in between fullscreen transition
 // notifications.
-IN_PROC_BROWSER_TEST_F(
+IN_PROC_BROWSER_TEST_P(
     WindowOcclusionBrowserTestMac,
+    //                       WindowOcclusionBrowserTestMacWithOcclusionDetectionFeature,
     IgnoreOcclusionUpdatesBetweenWindowFullscreenTransitionNotifications) {
   InitWindowA();
 
@@ -811,8 +907,9 @@ void TearDownInProcessBrowserTestFixture() override {
 
 // Tests that each web contents in a window receives an updated occlusion
 // state updated.
-IN_PROC_BROWSER_TEST_F(WindowOcclusionBrowserTestMac,
-                       OcclusionDetectionForMultipleWebContents) {
+IN_PROC_BROWSER_TEST_P(
+    WindowOcclusionBrowserTestMacWithOcclusionDetectionFeature,
+    OcclusionDetectionForMultipleWebContents) {
   InitWindowA();
 
   EXPECT_EQ(WindowAWebContentsVisibility(),
@@ -863,7 +960,7 @@ void TearDownInProcessBrowserTestFixture() override {
 }
 
 // Checks that web contentses are marked kHidden on WebContentsViewCocoa hide.
-IN_PROC_BROWSER_TEST_F(WindowOcclusionBrowserTestMac,
+IN_PROC_BROWSER_TEST_P(WindowOcclusionBrowserTestMac,
                        OcclusionDetectionOnWebContentsViewCocoaHide) {
   InitWindowA();
 
@@ -890,7 +987,7 @@ void TearDownInProcessBrowserTestFixture() override {
 
 // Checks that web contentses are marked kHidden on WebContentsViewCocoa removal
 // from the view hierarchy.
-IN_PROC_BROWSER_TEST_F(
+IN_PROC_BROWSER_TEST_P(
     WindowOcclusionBrowserTestMac,
     OcclusionDetectionOnWebContentsViewCocoaRemoveFromSuperview) {
   InitWindowA();
@@ -927,8 +1024,9 @@ void TearDownInProcessBrowserTestFixture() override {
 }
 
 // Checks that web contentses are marked kHidden on window miniaturize.
-IN_PROC_BROWSER_TEST_F(WindowOcclusionBrowserTestMac,
-                       OcclusionDetectionOnWindowMiniaturize) {
+IN_PROC_BROWSER_TEST_P(
+    WindowOcclusionBrowserTestMacWithOcclusionDetectionFeature,
+    OcclusionDetectionOnWindowMiniaturize) {
   InitWindowA();
 
   EXPECT_EQ(WindowAWebContentsVisibility(),
@@ -954,8 +1052,9 @@ void TearDownInProcessBrowserTestFixture() override {
 // triggering a visibility update, which causes a visibility watcher to add
 // a second child window (while we're still inside AppKit code adding the
 // first).
-IN_PROC_BROWSER_TEST_F(WindowOcclusionBrowserTestMac,
-                       ChildWindowListMutationDuringManualOcclusionDetection) {
+IN_PROC_BROWSER_TEST_P(
+    WindowOcclusionBrowserTestMacWithOcclusionDetectionFeature,
+    ChildWindowListMutationDuringManualOcclusionDetection) {
   InitWindowA();
 
   const NSRect kContentRect = NSMakeRect(0.0, 0.0, 20.0, 20.0);
@@ -984,8 +1083,9 @@ void TearDownInProcessBrowserTestFixture() override {
 
 // Tests that when a window becomes a child, if the occlusion system
 // previously marked it occluded, the window transitions to visible.
-IN_PROC_BROWSER_TEST_F(WindowOcclusionBrowserTestMac,
-                       WindowMadeChildForcedVisible) {
+IN_PROC_BROWSER_TEST_P(
+    WindowOcclusionBrowserTestMacWithOcclusionDetectionFeature,
+    WindowMadeChildForcedVisible) {
   InitWindowA();
 
   // Create a second window that occludes window_a.
diff --git a/content/common/features.cc b/content/common/features.cc
index d731cbb1739696d584182d614da1f4830c565440..eda8881f8938865087f379b481850292d5c5e9fc 100644
--- a/content/common/features.cc
+++ b/content/common/features.cc
@@ -261,6 +261,14 @@ BASE_FEATURE(kIOSurfaceCapturer,
              base::FEATURE_ENABLED_BY_DEFAULT);
 #endif
 
+// Feature that controls whether WebContentsOcclusionChecker should handle
+// occlusion notifications.
+#if BUILDFLAG(IS_MAC)
+BASE_FEATURE(kMacWebContentsOcclusion,
+             "MacWebContentsOcclusion",
+             base::FEATURE_ENABLED_BY_DEFAULT);
+#endif
+
 // If this feature is enabled, media-device enumerations use a cache that is
 // invalidated upon notifications sent by base::SystemMonitor. If disabled, the
 // cache is considered invalid on every enumeration request.
diff --git a/content/common/features.h b/content/common/features.h
index 8cbb478cc879c9f4048f264d8d2f8c1fda7d6f7e..394612e6b25b93720307c2730270c760f484a13f 100644
--- a/content/common/features.h
+++ b/content/common/features.h
@@ -68,6 +68,9 @@ CONTENT_EXPORT BASE_DECLARE_FEATURE(kInterestGroupUpdateIfOlderThan);
 #if BUILDFLAG(IS_MAC)
 CONTENT_EXPORT BASE_DECLARE_FEATURE(kIOSurfaceCapturer);
 #endif
+#if BUILDFLAG(IS_MAC)
+CONTENT_EXPORT BASE_DECLARE_FEATURE(kMacWebContentsOcclusion);
+#endif
 CONTENT_EXPORT BASE_DECLARE_FEATURE(kMediaDevicesSystemMonitorCache);
 CONTENT_EXPORT BASE_DECLARE_FEATURE(kMediaStreamTrackTransfer);
 CONTENT_EXPORT BASE_DECLARE_FEATURE(kMojoDedicatedThread);
diff --git a/testing/variations/fieldtrial_testing_config.json b/testing/variations/fieldtrial_testing_config.json
index bb02881fa104feac4926864df4df140dd1d11ad9..5c499898616fb7442e9b33fca881ba2443303363 100644
--- a/testing/variations/fieldtrial_testing_config.json
+++ b/testing/variations/fieldtrial_testing_config.json
@@ -13478,6 +13478,24 @@
             ]
         }
     ],
+    "MacWebContentsOcclusionV2": [
+        {
+            "platforms": [
+                "mac"
+            ],
+            "experiments": [
+                {
+                    "name": "Enabled",
+                    "params": {
+                        "EnhancedWindowOcclusionDetection": "true"
+                    },
+                    "enable_features": [
+                        "MacWebContentsOcclusion"
+                    ]
+                }
+            ]
+        }
+    ],
     "MagicStackGradientView": [
         {
             "platforms": [
