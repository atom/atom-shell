From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Keeley Hammond <khammond@slack-corp.com>
Date: Tue, 3 Sep 2024 12:38:51 +0100
Subject: feat: allow desktop capturer to return either screen, window or both


diff --git a/chrome/browser/media/webrtc/capture_policy_utils.cc b/chrome/browser/media/webrtc/capture_policy_utils.cc
index 3e076d38bec2336294d74f0f1a607877d554049a..5e79a54ea9d7581252aeaa0cf961a3c375887e18 100644
--- a/chrome/browser/media/webrtc/capture_policy_utils.cc
+++ b/chrome/browser/media/webrtc/capture_policy_utils.cc
@@ -405,6 +405,7 @@ void FilterMediaList(std::vector<DesktopMediaList::Type>& media_types,
       media_types, [capture_level](const DesktopMediaList::Type& type) {
         switch (type) {
           case DesktopMediaList::Type::kNone:
+            // return capture_level < AllowedScreenCaptureLevel::kDesktop;
             NOTREACHED();
           // SameOrigin is more restrictive than just Tabs, so as long as
           // at least SameOrigin is allowed, these entries should stay.
diff --git a/chrome/browser/media/webrtc/native_desktop_media_list.cc b/chrome/browser/media/webrtc/native_desktop_media_list.cc
index 68ece50018124992f951557e817a12aa45d65956..7368f26a41907e5004744a07ffe986f036e00b8d 100644
--- a/chrome/browser/media/webrtc/native_desktop_media_list.cc
+++ b/chrome/browser/media/webrtc/native_desktop_media_list.cc
@@ -182,14 +182,16 @@ BASE_FEATURE(kWindowCaptureMacV2,
 
 content::DesktopMediaID::Type ConvertToDesktopMediaIDType(
     DesktopMediaList::Type type) {
+  // LOG(INFO) << "Inside ConvertToDesktopMediaIDType";
   switch (type) {
     case DesktopMediaList::Type::kScreen:
       return content::DesktopMediaID::Type::TYPE_SCREEN;
     case DesktopMediaList::Type::kWindow:
       return content::DesktopMediaID::Type::TYPE_WINDOW;
+    case DesktopMediaList::Type::kNone:
+      // return content::DesktopMediaID::Type::TYPE_NONE;
     case DesktopMediaList::Type::kWebContents:
     case DesktopMediaList::Type::kCurrentTab:
-    case DesktopMediaList::Type::kNone:
       break;
   }
   NOTREACHED();
@@ -533,7 +535,10 @@ NativeDesktopMediaList::Worker::FormatSources(
   std::vector<SourceDescription> source_descriptions;
   std::u16string title;
   for (size_t i = 0; i < sources.size(); ++i) {
+    // LOG(INFO) << "source_type" << source_type;
     switch (source_type) {
+      // case DesktopMediaID::Type::TYPE_NONE:
+        // continue;
       case DesktopMediaID::Type::TYPE_SCREEN:
         // Just in case 'Screen' is inflected depending on the screen number,
         // use plural formatter.
diff --git a/content/browser/media/capture/native_screen_capture_picker_mac.mm b/content/browser/media/capture/native_screen_capture_picker_mac.mm
index 1b8e95f476a032f60ea7e578fac480344924ab50..85693c76c41d9b17bac5f69e99f4f9a4c5003e9c 100644
--- a/content/browser/media/capture/native_screen_capture_picker_mac.mm
+++ b/content/browser/media/capture/native_screen_capture_picker_mac.mm
@@ -94,6 +94,7 @@ void Open(DesktopMediaID::Type type,
             base::OnceCallback<void(Source)> picker_callback,
             base::OnceCallback<void()> cancel_callback,
             base::OnceCallback<void()> error_callback) override;
+            // boolean use_system_picker) override;
   void Close(DesktopMediaID device_id) override;
   std::unique_ptr<media::VideoCaptureDevice> CreateDevice(
       const DesktopMediaID& source) override;
@@ -131,12 +132,13 @@ void Open(DesktopMediaID::Type type,
     base::OnceCallback<void(Source)> picker_callback,
     base::OnceCallback<void()> cancel_callback,
     base::OnceCallback<void()> error_callback) {
+    // boolean use_system_picker) {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
   // Chrome doesn't allow both screens & windows in their picker,
   // but Electron does - add a check for TYPE_NONE.
-  CHECK(type == DesktopMediaID::Type::TYPE_SCREEN ||
-        type == DesktopMediaID::Type::TYPE_WINDOW ||
-        type == DesktopMediaID::Type::TYPE_NONE);
+  // CHECK(type == DesktopMediaID::Type::TYPE_SCREEN ||
+  //       type == DesktopMediaID::Type::TYPE_WINDOW ||
+  //       type == DesktopMediaID::Type::TYPE_NONE);
   if (@available(macOS 14.0, *)) {
     NSNumber* source_id = @(next_id_);
     auto picker_observer = [[PickerObserver alloc]
@@ -155,11 +157,24 @@ void Open(DesktopMediaID::Type type,
     // restart.
     config.allowsChangingSelectedContent = true;
     NSNumber* max_stream_count = @(kMaxContentShareCountValue.Get());
+    // LOG(ERROR) << "Type: " << type;
     // Chrome doesn't allow both screens & windows in their picker,
     // but Electron does; we patch out the MediaID::Type conditional here
+    // if (type == DesktopMediaID::Type::TYPE_SCREEN) {
+    //   config.allowedPickerModes = SCContentSharingPickerModeSingleDisplay;
+    //   picker.defaultConfiguration = config;
+    //   picker.maximumStreamCount = max_stream_count;
+    //   [picker presentPickerUsingContentStyle:SCShareableContentStyleDisplay];
+    // } else if (type == DesktopMediaID::Type::TYPE_WINDOW) {
+    //   config.allowedPickerModes = SCContentSharingPickerModeSingleWindow;
+    //   picker.defaultConfiguration = config;
+    //   picker.maximumStreamCount = max_stream_count;
+    //   [picker presentPickerUsingContentStyle:SCShareableContentStyleWindow];
+    // } else {
     picker.defaultConfiguration = config;
     picker.maximumStreamCount = max_stream_count;
     [picker present];
+    // }
   } else {
     NOTREACHED();
   }
